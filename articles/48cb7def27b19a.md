---
title: "RustとWebAssemblyによるゲーム開発を読み進めたらつまづきまくったので備忘録"
emoji: "🗂"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [nix, Rust, WebAssembly, direnv]
published: true
---

findyのoreilly learningプラットフォームが90日無料で試せるヤツの抽選に当たってました
1ヶ月もそれに気付かず放置していたら、findyさんの方から「抽選当たってるでー気づいてー」とメッセージが来たので早速試しています（findyさんごめんなさいありがとう）
手始めに、諸事情で序盤以降が読めなくなってしまっていた
[RustとWebAssemblyによるゲーム開発](https://learning.oreilly.com/library/view/rusttowebassemblyniyorugemukai-fa-an-quan-gao-su-puratutohuomufei-yi-cun-nowebapurikai-fa-ru-men/9784814400393/)
という本を読み進めています

本の扱っている内容が発展途上の分野な為変化が早く、ツールの使い方などは特に詰まりやすいなと思ったので備忘録として残すことにしました

> [!caution]
> 以下、2025/10/01時点での情報です

## rustupの代わりにnixを使っている場合の注意点

自分は [fenix](https://github.com/nix-community/fenix) というoverlayを利用してrustのツールチェーンをインストールしています
普通にインストールしていると`cargo`ひいては`rustc`コマンドのターゲットはホストプラットフォームになっているかと思います
たとえば自分は、apple siliconのmacなので

```sh
❯ rustc -v -V
rustc 1.92.0-nightly (dc2c3564d 2025-09-29)
binary: rustc
commit-hash: dc2c3564d273cf8ccce32dc4f47eaa27063bceb9
commit-date: 2025-09-29
host: aarch64-apple-darwin # ←これがデフォルトのターゲット
release: 1.92.0-nightly
LLVM version: 21.1.2
```

となっています

wasm（具体的に、今回の場合はwasm32-unknown-unknown)をターゲットにビルドする際、
rustupを使っている場合は単純に`rustup`コマンド経由でwasm32-unknown-unknownをインストールすれば良いのですが、rustupを使わない場合は別の方法でターゲットプラットフォームをインストールする必要があります

自分の場合はdevshellを利用して環境構築をしているので、flake.nixを以下のように設定します

```nix
{
  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs/nixpkgs-unstable";
    flake-utils.url = "github:numtide/flake-utils";
    fenix.url = "github:nix-community/fenix";
    fenix.inputs.nixpkgs.follows = "nixpkgs";
  };

  outputs =
    {
      self,
      nixpkgs,
      flake-utils,
      fenix,
    }:
    flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
        fx = fenix.packages.${system};
        toolchain = fx.combine [
          fx.latest.rustc
          fx.latest.cargo
          fx.latest.rustfmt
          fx.latest.clippy
          fx.latest.rust-src
          fx.targets.wasm32-unknown-unknown.latest.rust-std
        ];
      in
      {
        devShells.default = pkgs.mkShell {
          buildInputs = [
            pkgs.nodejs_24
            pkgs.wasm-pack
            toolchain
          ];

          shellHook = ''
            echo -e "\033[1;32m\nRust + WASM dev environment loaded"
            echo -e "System: ${system}"
            echo -e "wasm-pack: $(which wasm-pack 2>/dev/null || echo 'not found')"
            echo -e "rustc:     $(which rustc 2>/dev/null || echo 'not found')"
            echo -e "cargo:     $(which cargo 2>/dev/null || echo 'not found')\033[0m\n"
          '';
        };
      }
    );
}
```

> [!tip]
> shellHookで実行している echo 内に\033[1 ... と見慣れぬコードがありますが、これはansi escape
> sequence というものです
> ansi escape sequence自体の説明は
> https://stackoverflow.com/questions/4842424/list-of-ansi-color-escape-sequences
> ↑のリンクの回答がわかりやすいです

`fx.combine`に渡される配列内で示されたコンポーネントをひとまとまりのツールチェーンとして利用できる（という理解なんですけど合ってる？）
ので、あとは`toolchain`をbuildInputsに指定してやればwasm32-unknown-unknown問題は解決します

shellでrustcのパスを確認してみましょう

```sh
❯ wh rustc
rustc is /nix/store/nixqji36ybcpjipvq5xh17i9zimmn58a-rust-mixed/bin/rustc
rustc is /Users/a/.nix-profile/bin/rustc
```

devshellのパスが先に来てたらOKです
稀にneovimのterminalバッファを使っているとグローバルな方が先に来てしまうのですが、
その状態で`npm run start`すると

```
Error: wasm32-unknown-unknown target not found in sysroot: "/nix/store/7qqwr576zn72lib96j4kig162agh4cb9-rust-nightly-latest-2025-09-30"

Used rustc from the following path: "/Users/a/.nix-profile/bin/rustc"
It looks like Rustup is not being used. For non-Rustup setups, the wasm32-unknown-unknown target needs to be installed manually. See https://rustwasm.github.io/wasm-pack/book/prerequisites/non
-rustup-setups.html on how to do this.
```

というエラーが出るので、devshellをリロードしましょう
自分の場合はdirenvを使っているので一旦ディレクトリを抜けて戻ると解決します

## テンプレートが古い

本の中でも言及されていますが、テンプレートがだいぶ古くなっています
`npm init rust-webpack`で生成されるCargo.tomlのエディションはなんと2018..
本の中でも軽くアップデートしていますが、それでもまだ古いのでエラーが出てしまいました
ということで、本腰を入れて更新作業をする必要があります

### 目標

ブラウザのコンソールで"Hello World!"と出力されているのを確認する

因みに、`npm init rust-webpack`で生成される`src/lib.rs`は↓です

```rust
use wasm_bindgen::prelude::*;
use web_sys::console;

// When the `wee_alloc` feature is enabled, this uses `wee_alloc` as the global
// allocator.
//
// If you don't want to use `wee_alloc`, you can safely delete this.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// This is like the `main` function, except for JavaScript.
#[wasm_bindgen(start)]
pub fn main_js() -> Result<(), JsValue,> {
	// This provides better error messages in debug mode.
	// It's disabled in release mode so it doesn't bloat up the file size.
	#[cfg(debug_assertions)]
	console_error_panic_hook::set_once();

	// Your code goes here!
	console::log_1(&JsValue::from_str("Hello world!",),);

	Ok((),)
}
```

### Rust側

実はRust側の更新はそんなに大変ではありません
Cargo.tomlをいじるだけです
自分の場合は↓な感じにしました

```toml
# You must change these to your own details.
[package]
name = "rust-webpack-template"
version = "0.1.0"
authors = ["You <you@example.com>"]
categories = ["wasm"]
edition = "2024"
readme = "README.md"
description = "My super awesome Rust, WebAssembly, and Webpack project!"

[lib]
crate-type = ["cdylib"]

[profile.release]
# This makes the compiled code faster and smaller, but it makes compiling slower,
# so it's only enabled in release mode.
lto = true

[features]
# If you uncomment this line, it will enable `wee_alloc`:
# default = ["wee_alloc"]

[dependencies]
# The `wasm-bindgen` crate provides the bare minimum functionality needed
# to interact with JavaScript.
wasm-bindgen = "*"
console_error_panic_hook = "*"

# `wee_alloc` is a tiny allocator for wasm that is only ~1K in code size
# compared to the default allocator's ~10K. However, it is slower than the default
# allocator, so it's not enabled by default.
wee_alloc = { version = "*", optional = true }

# The `web-sys` crate allows you to interact with the various browser APIs,
# like the DOM.
[dependencies.web-sys]
version = "*"
features = ["console"]

# The `console_error_panic_hook` crate provides better debugging of panics by
# logging them with `console.error`. This is great for development, but requires
# all the `std::fmt` and `std::panicking` infrastructure, so it's only enabled
# in debug mode.

# These crates are used for running unit tests.
[dev-dependencies]
futures = "*"
js-sys = "*"
wasm-bindgen-futures = "*"
wasm-bindgen-test = "*"
```

### js(ツール)側

こちらは大変です..というか大変でした

が、結局やる事としては

1. package.jsonの修正
2. webpack.config.jsの修正

の二つです

#### package.jsonの修正

```json
{
	"author": "You <you@example.com>",
	"name": "rust-webpack-template",
	"version": "0.1.0",
	"scripts": {
		"build": "webpack --mode production",
		"start": "webpack serve --open --mode development",
		"test": "cargo test && wasm-pack test --headless"
	},
	"devDependencies": {
		"@wasm-tool/wasm-pack-plugin": "*",
		"copy-webpack-plugin": "^5.0.3",
		"webpack": "^5.102.0",
		"webpack-cli": "^5.1.4",
		"webpack-dev-server": "*"
	}
}
```

正直nodeの使い方とかwebpack側の事情とか知ったこっちゃなので荒い修正なのは自覚しています
とりあえずこれで動くからええねんの精神で自分に言い訳していますが、指摘などあったら教えてください
涎垂らして喜びます

修正点としてはwebpackパッケージのアップデート（テンプレだと４系なので５系に）とそれに伴ったビルドコマンドの変更です

#### webpack.config.js

```js
const path = require("path");
const WasmPackPlugin = require("@wasm-tool/wasm-pack-plugin");
const CopyWebpackPlugin = require("copy-webpack-plugin");

module.exports = {
  mode: "development",
  entry: "./js/index.js",
  // 必要
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "main.js",
    publicPath: "auto",
    clean: true,
  },
  experiments: {
    asyncWebAssembly: true,
    topLevelAwait: true,
  },
  module: {
    rules: [{ test: /\.wasm$/, type: "webassembly/async" }],
  },
  resolve: { extensions: [".js", ".wasm"] },
  // 必要
  devServer: {
    static: path.join(__dirname, "static"),
    hot: true,
    port: 8081,
  },
  devtool: "source-map",
  plugins: [
    new WasmPackPlugin({
      crateDirectory: path.resolve(__dirname),
      outDir: path.resolve(__dirname, "pkg"),
      extraArgs: "--target bundler",
      forceMode: "development",
    }),
    // 必要
    new CopyWebpackPlugin([
      { from: path.resolve(__dirname, "static"), to: path.resolve(__dirname, "dist") },
    ]),
  ],
};
```

こちらもと・動・え精神でごちゃごちゃを許容しています
指摘などあったら(ry

保証はできませんが、↑で*必要*とコメントされているブロックに関しては最低限必要な設定かと思われます
こいつらがないとビルドアーティファクトをちゃんと使ってくれなくなります

### 確認してみよう

ここまで修正すれば、ブラウザのコンソールに`console::log_1`へ渡した値が出力されているかと思います

されていない場合はwasmを読み込むjs側のエントリーポイントで、生成されたスクリプトをロードしているか確認しましょう

```js
import "../pkg/index.js";
```

`webpack.config.js`を再掲すると、自分は↓のようにjs/index.jsをエントリーポイントに指定しています

```js
const path = require("path");
const WasmPackPlugin = require("@wasm-tool/wasm-pack-plugin");
const CopyWebpackPlugin = require("copy-webpack-plugin");

module.exports = {
  mode: "development",
  entry: "./js/index.js",
  // 必要
  output: {
    path: path.resolve(__dirname, "dist"),

...
```

# 個人的tips

rustで外部クレートを利用する際によくお世話になる [docs.rs](https://docs.rs/)
ですが、実はtype based searchができます

例えば、web_sysクレートで

&JsValue -> HtmlCanvasElement

と検索すると↓のような結果が得られます

https://docs.rs/web-sys/latest/web_sys/struct.Element.html?search=%26JsValue%20-%3E%20HtmlCanvasElement

意外と知られてないこの機能ですが、🔍(Search)ボタンの右にある?(Help)ボタンをおすとガッツリ紹介されています
結構柔軟にクエリが書けて便利です

docs.rsを徘徊する時に記憶の端っこにあるとオイシイかもしれません
