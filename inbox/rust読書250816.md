# 4.3章 スライス型

## 議論するポイント

- **スライスの概念と必要性**
  - なぜインデックスを返すだけでは不十分なのか？
  - データの整合性を保つためのRustの仕組み
  - 所有権システムとスライスの関係

- **文字列スライス（&str）の特徴**
  - String型と&str型の使い分け
  - 文字列リテラルが&str型である理由
  - UTF-8文字境界の重要性

- **借用チェッカーの働き**
  - コンパイル時エラーによる安全性の確保
  - 可変借用と不変借用の競合検出
  - メモリ安全性の保証

- **APIの設計思想**
  - &Stringより&strを引数に取る利点
  - deref coercionによる柔軟性
  - 汎用性と使いやすさのバランス

## 理解度チェック


2. `&String`と`&str`の違いは何ですか？どちらを関数の引数として使うべきでしょうか？

3. 文字列リテラル`"hello"`の型は何ですか？その理由も説明してください。

4. スライス`&s[2..5]`が指すメモリ領域について説明してください。

5. 配列スライス`&[i32]`と文字列スライス`&str`の共通点と相違点は何ですか？

## 課題

### 基礎課題

1. **last_word関数の実装**
   文字列の最後の単語を返す関数を実装してください。
```rust
fn last_word(s: &str) -> &str {
    // ここに実装
}
```

2. **単語数カウント関数**
   文字列内の単語数を数える関数を実装してください。
```rust
fn word_count(s: &str) -> usize {
    // ここに実装
}
```

3. **配列スライスの操作**
   整数配列から偶数のみを含む新しいVecを作成する関数を実装してください。
```rust
fn filter_even(numbers: &[i32]) -> Vec<i32> {
    // ここに実装
}
```

### 中級課題

4. **文字列の分割**
   指定された区切り文字で文字列を分割し、各部分をスライスとして返す関数を実装してください。
```rust
fn split_by_char(s: &str, delimiter: char) -> Vec<&str> {
    // ここに実装
}
```

5. **安全な部分文字列取得**
   指定された範囲が有効なutf-8文字列境界である場合のみ部分文字列を返すOption型を使った関数を実装してください。
```rust
fn safe_substring(s: &str, start: usize, end: usize) -> Option<&str> {
    // ここに実装
}
```

## 発展

### 発展課題

1. **カスタムスライス型の実装**
   独自の構造体に対してスライスのような機能を提供するカスタム型を実装してください。以下の要件を満たしてください：
   - 元のデータへの参照を保持
   - 範囲指定による部分取得
   - イテレータの実装
   - インデックスアクセスの実装

```rust
struct MySlice<'a, T> {
    // フィールドを定義
}

impl<'a, T> MySlice<'a, T> {
    fn new(data: &'a [T], start: usize, end: usize) -> Option<Self> {
        // 実装
    }
    
    fn len(&self) -> usize {
        // 実装
    }
    
    fn get(&self, index: usize) -> Option<&T> {
        // 実装
    }
}
```

2. **高性能文字列検索**
   Boyer-Moore法やKMP法を使った高性能な文字列検索アルゴリズムを実装し、スライスを活用してメモリ効率的な検索を行ってください。

```rust
struct StringSearcher<'a> {
    pattern: &'a str,
    // 必要なフィールドを追加
}

impl<'a> StringSearcher<'a> {
    fn new(pattern: &'a str) -> Self {
        // 実装
    }
    
    fn find_all(&self, text: &str) -> Vec<usize> {
        // パターンが見つかった全ての位置を返す
    }
    
    fn find_first(&self, text: &str) -> Option<usize> {
        // 最初に見つかった位置を返す
    }
}
```

3. **ゼロコピー文字列パーサー**
   CSVやJSONのような構造化データを、元の文字列をコピーすることなくスライスのみを使って解析するパーサーを実装してください。

```rust
#[derive(Debug)]
struct CsvRow<'a> {
    fields: Vec<&'a str>,
}

struct CsvParser;

impl CsvParser {
    fn parse_line(line: &str) -> Result<CsvRow, impl std::error::Error> {
        // 実装：元の文字列をコピーせずにスライスのみを使用
    }
    
    fn parse_file(content: &str) -> Result<Vec<CsvRow>, impl std::error::Error> {
        // 実装：ファイル全体を解析
    }
}
```

### 実践プロジェクト

4. **テキストエディタのバッファ管理**
   大きなテキストファイルを効率的に扱うためのバッファ管理システムを実装してください：
   - 行単位でのスライス管理
   - 部分的な読み込みと表示
   - 編集操作の効率的な実装
   - メモリ使用量の最適化
