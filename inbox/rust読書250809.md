https://doc.rust-jp.rs/book-ja/ch04-00-understanding-ownership.html

https://doc.rust-jp.rs/book-ja/ch04-02-references-and-borrowing.html

# 4.2 参照と借用

> [!abstract]
>所有権を取らずに参照を使用する方法、可変参照と不変参照、借用ルール、ダングリング参照の防止について理解する。
>1. **参照は所有権の移転なしに借用を可能にする**
>2. **可変参照は排他的；不変参照は共有可能**
>3. **Rustは借用ルールによりコンパイル時にデータ競合を防ぐ**
>4. **参照のスコープは字句的スコープではなく使用によって決まる**
>5. **借用チェッカーは味方 - バグが発生する前に防いでくれる**

## 議論

- なぜRust初心者は借用チェッカーに苦労するんだろう
-  実際には参照と所有値をいつ使い分けるか？
  - 関数パラメータ
  - データ構造設計
  - API設計の考慮事項
- Rustのエラーメッセージは言語学習にどう役立つか？
- RustのリファレンスはC++のポインタや他言語のリファレンスとどう違うか？

## 理解度チェック

### 問題1: 基本的な参照
```rust
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);
    println!("Length: {}", len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```
**Q**: なぜ `calculate_length` を呼び出した後でも `s1` を使用できるのか？

### 問題2: 可変参照
```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
    println!("{}", s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
**Q**: `change`内で値を変更するために必要な3つの条件は？

### 問題3: 借用ルール違反
```rust
fn main() {
    let mut s = String::from("hello");
    let r1 = &mut s;
    let r2 = &mut s;  // エラー
    println!("{}, {}", r1, r2);
}
```
**Q**: なぜこのコードはコンパイルに失敗するのか？

### 問題4: 混合参照
```rust
fn main() {
    let mut s = String::from("hello");
    let r1 = &s;      // 不変
    let r2 = &s;      // 不変
    let r3 = &mut s;  // エラー！
    println!("{}, {}, {}", r1, r2, r3);
}
```
**Q**: なぜこれは無効なのか？

### 問題5: 参照のスコープ
```rust
fn main() {
    let mut s = String::from("hello");
    let r1 = &s;
    let r2 = &s;
    println!("{} and {}", r1, r2);
    
    let r3 = &mut s; 
    println!("{}", r3);
}
```
**Q**: なぜこのコードは正常にコンパイルされるのか？

## 課題

### 演習1: 参照への変換
この所有権ベースのコードを参照を使用するように変換してください：
```rust
fn main() {
    let s = String::from("hello world");
    let word = first_word(s);  // sはここで移動される
    // println!("{}", s);  // これはエラーになる
    println!("{}", word);
}

fn first_word(s: String) -> String {
    // 最初の単語を返す
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return s[0..i].to_string();
        }
    }
    s
}
```

### 演習2: 借用エラーの修正
このコードのコンパイルエラーを修正してください：
```rust
fn main() {
    let mut data = vec![1, 2, 3, 4, 5];
    let first = &data[0];
    data.push(6);
    println!("First element: {}", first);
}
```

### 演習3: 安全なカウンタの実装
カウンタを安全にインクリメントする関数を作成してください：
```rust
fn main() {
    let mut count = 0;
    increment_counter(/* ここにパラメータを記述 */);
    println!("Count: {}", count);  // "Count: 1"と出力されるべき
}

fn increment_counter(/* ここにパラメータを記述 */) {
    // この関数を実装してください
}
```

### 演習4: 参照ライフタイムの理解
なぜこのコードがコンパイルされないのかを説明し、修正してください：
```rust
fn main() {
    let r;
    {
        let x = 5;
        r = &x;  // エラー！
    }
    println!("r: {}", r);
}
```

## 発展

### チャレンジ1: 安全なキャッシュの設計
所有権を取らずに文字列参照を保存するシンプルなキャッシュを実装してください：
```rust
struct StringCache<'a> {
    // ここにフィールドを設計してください
}

impl<'a> StringCache<'a> {
    fn new() -> Self {
        // 実装してください
    }
    
    fn store(&mut self, key: &str, value: &'a str) {
        // 所有権を取らずに保存
    }
    
    fn get(&self, key: &str) -> Option<&'a str> {
        // 参照を取得
    }
}

fn main() {
    let data = String::from("cached value");
    let mut cache = StringCache::new();
    cache.store("key1", &data);
    
    if let Some(value) = cache.get("key1") {
        println!("Found: {}", value);
    }
}
```

### チャレンジ2: 参照ベースの木の走査の実装
参照を使用して走査できる二分木を作成してください：
```rust
#[derive(Debug)]
struct TreeNode {
    value: i32,
    left: Option<Box<TreeNode>>,
    right: Option<Box<TreeNode>>,
}

impl TreeNode {
    fn new(value: i32) -> Self {
        TreeNode {
            value,
            left: None,
            right: None,
        }
    }
    
    // 参照を使用してこれらのメソッドを実装してください
    fn find(&self, target: i32) -> Option<&TreeNode> {
        // 見つかった場合はノードへの参照を返す
    }
    
    fn find_mut(&mut self, target: i32) -> Option<&mut TreeNode> {
        // 見つかった場合はノードへの可変参照を返す
    }
    
    fn collect_values(&self) -> Vec<&i32> {
        // すべての値への参照を収集
    }
}
```

### チャレンジ3: 複数参照データ構造
複数の参照を安全に管理するデータ構造を設計してください：
```rust
struct MultiRef<T> {
    data: Vec<T>,
    // 参照を安全に追跡するフィールドを追加
}

impl<T> MultiRef<T> {
    fn new() -> Self {
        // 実装してください
    }
    
    fn add(&mut self, item: T) -> usize {
        // アイテムを追加してインデックスを返す
    }
    
    fn get(&self, index: usize) -> Option<&T> {
        // 不変参照を取得
    }
    
    fn get_multiple(&self, indices: &[usize]) -> Vec<Option<&T>> {
        // 複数の参照を安全に取得
    }
}
```

### チャレンジ4: 参照ベースのイテレータ
参照を生成するカスタムイテレータを実装してください：
```rust
struct RefIterator<'a, T> {
    data: &'a [T],
    current: usize,
}

impl<'a, T> RefIterator<'a, T> {
    fn new(data: &'a [T]) -> Self {
        // 実装してください
    }
}

impl<'a, T> Iterator for RefIterator<'a, T> {
    type Item = &'a T;
    
    fn next(&mut self) -> Option<Self::Item> {
        // 参照を生成するイテレータを実装
    }
}

// 使用例：
fn main() {
    let data = vec![1, 2, 3, 4, 5];
    let iter = RefIterator::new(&data);
    
    for item_ref in iter {
        println!("Item: {}", item_ref);
    }
}
```

---

## 参考
- [Rust Reference: References](https://doc.rust-lang.org/reference/types/pointer.html#references--and-mut)
- [Rustlings Exercises: Move Semantics](https://github.com/rust-lang/rustlings)
